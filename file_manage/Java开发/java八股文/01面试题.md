面向对象

JDK、JRE、JVM的区别

==、equals()、hashCode()的区别
==是比较两个变量的值是否相等，equals()是比较两个对象的内容是否相等，hashCode()是比较两个对象的哈希值是否相等。
==比较对象时，会比较两个引用是否指向堆内存中的同一个对象实例
equals()比较对象时，会比较两个对象的内容是否相等，如果没有重写equals()方法，那么它和==的作用是一样的
hashCode返回一个整数，由对象的内存地址转换而来，如果没有重写hashCode()方法，那么它会根据对象的内存地址计算哈希值，所以两个对象的哈希值一定不相等



final关键字的作用
final可以修饰类、方法和变量，分别表示：
final修饰的类不能被继承
final修饰的方法不能被重写
final修饰的变量不能被修改，如果修饰的是基本数据类型，那么它的值不能被修改；如果修饰的是引用类型，那么它的引用不能被修改，但是它所指向的对象可以被修改

String、StringBuffer、StringBuilder的区别
String是不可变的，也就是说一旦创建，其值就不能改变；StringBuffer和StringBuilder是可变的，它们的值可以随时改变
StringBuffer是线程安全的，而StringBuilder是线程不安全的

重载和重写的区别
重载是指在同一个类中，方法名相同，参数列表不同，返回值可以相同也可以不同，访问修饰符可以相同也可以不同，抛出的异常可以相同也可以不同
重写是指子类重写父类的方法，方法名、参数列表、返回值必须相同，访问修饰符的范围必须大于等于父类的访问修饰符，抛出的异常必须小于等于父类抛出的异常

抽象类和接口的区别
抽象类和接口都不能被实例化，它们都是用来被继承的
抽象类可以有构造方法，接口不能有构造方法
抽象类中可以有普通成员变量，接口中没有普通成员变量
抽象类中可以有非抽象的普通方法，接口中的所有方法都必须是抽象的
抽象类中可以有静态方法，接口中不能有静态方法
抽象类中可以有静态代码块，接口中不能有静态代码块
抽象类中可以有静态成员变量，接口中不能有静态成员变量
一个类可以实现多个接口，但只能继承一个抽象类
抽象类中的抽象方法的访问修饰符可以是public、protected和default，但不能是private；接口中的方法的访问修饰符只能是public

Java中的四种引用
强引用：只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象
软引用：如果一个对象只有软引用，那么当内存空间不足时，垃圾回收器可能会回收该对象，但是也可能不会回收该对象，这取决于垃圾回收器的算法
弱引用：如果一个对象只有弱引用，那么当垃圾回收器扫描到该对象时，不管当前内存空间是否足够，都会回收该对象
虚引用：如果一个对象只有虚引用，那么它就和没有引用一样，在任何时候都可能被垃圾回收器回收，虚引用主要用来跟踪对象被垃圾回收器回收的活动

List和Set的区别
List是有序的，Set是无序的
List中的元素可以重复，Set中的元素不能重复
List中的元素是可以为null的，Set中只能有一个null元素
List中的元素是按照插入顺序排序的，Set中的元素是按照哈希值排序的

HashMap和Hashtable的区别
HashMap是线程不安全的，Hashtable是线程安全的
HashMap中的key和value都可以为null，Hashtable中的key和value都不能为null
HashMap中的元素是无序的，Hashtable中的元素是有序的

ArrayList和LinkedList的区别
ArrayList是基于数组实现的，LinkedList是基于链表实现的
ArrayList是非线程安全的，LinkedList是非线程安全的
ArrayList的插入和删除操作效率低，LinkedList的插入和删除操作效率高
ArrayList的随机访问效率高，LinkedList的随机访问效率低

Java中的异常
Throwable是所有异常的父类，它有两个子类：Error和Exception
Error表示严重的错误，程序对此一般无能为力，例如内存溢出、栈溢出等，这些错误发生时，程序一般会终止运行
Exception表示一般的异常，它又有两个子类：RuntimeException和CheckedException
RuntimeException表示运行时异常，程序在运行时可能会出现的异常，例如空指针异常、数组下标越界异常等，这些异常可以被捕获，也可以不被捕获，如果不被捕获，程序会终止运行
CheckedException表示检查时异常，程序在编译时可能会出现的异常，例如IO异常、ClassNotFoundException等，这些异常必须被捕获，否则程序无法编译通过

Java中的异常处理
Java中的异常处理主要有两种方式：try-catch-finally和throws
try-catch-finally用来捕获异常，如果try中的代码出现了异常，那么就会跳转到catch中，如果没有出现异常，那么就不会跳转到catch中，finally中的代码无论是否出现异常都会被执行
throws用来声明异常，如果一个方法中可能会出现异常，那么就需要在方法的声明处使用throws来声明异常，如果一个方法中调用了另一个方法，而被调用的方法可能会出现异常，那么就需要在被调用的方法的声明处使用throws来声明异常

ConcurrentHashMap和Hashtable的区别
ConcurrentHashMap是线程安全的，Hashtable也是线程安全的
ConcurrentHashMap中的key和value都不能为null，Hashtable中的key和value都不能为null
ConcurrentHashMap中的元素是无序的，Hashtable中的元素是有序的

泛型
泛型是JDK1.5之后出现的新特性，它可以将类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型
泛型的好处是可以在编译时检查出类型错误，避免了类型转换的麻烦
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数

Java中的反射
Java中的反射是指在运行时动态的获取类的信息，以及动态的调用类的方法或构造方法
Java中的反射主要有三个类：Class、Method和Constructor
Class类表示类的信息，Method类表示类的方法的信息，Constructor类表示类的构造方法的信息
Java中的反射主要用来实现依赖注入和动态代理

Java中的注解
Java中的注解是从JDK1.5之后出现的新特性，它可以用来为程序的元素（类、方法、成员变量等）添加额外的信息，这些信息可以在编译时被读取，并被一些工具类所用
Java中的注解主要有三种：@Override、@Deprecated和@SuppressWarnings
@Override表示该方法是重写的父类的方法，如果该方法不是重写的父类的方法，那么编译器会报错
@Deprecated表示该方法已经过时，不建议使用
@SuppressWarnings表示忽略指定的警告，例如@SuppressWarnings("unchecked")表示忽略未检查的警告

Java中的序列化
Java中的序列化是指将对象转换为字节序列的过程，反序列化是指将字节序列恢复为对象的过程
Java中的序列化主要有两种方式：Serializable和Externalizable
Serializable是JDK提供的序列化接口，它是一个空接口，如果一个类实现了Serializable接口，那么它就可以被序列化
Externalizable是JDK提供的序列化接口，它继承了Serializable接口，如果一个类实现了Externalizable接口，那么它就可以被序列化，但是它比Serializable接口更加灵活，因为它可以在序列化时控制序列化的内容，而Serializable接口不能做到这一点

类加载器
类加载器是用来将类的字节码文件加载到内存中，并生成对应的Class对象
类加载器主要有三种：BootStrap ClassLoader、Extension ClassLoader和App ClassLoader
BootStrap ClassLoader是用来加载JDK中的核心类库的，它是用C++实现的，所以在Java中看不到它的身影
Extension ClassLoader是用来加载JDK中的扩展类库的，它是用Java实现的，它的父类是BootStrap ClassLoader
App ClassLoader是用来加载应用程序中的类的，它是用Java实现的，它的父类是Extension ClassLoader

Java中的代理
Java中的代理主要有两种：静态代理和动态代理
静态代理是指在程序运行之前就已经存在代理类的字节码文件，代理类和被代理类的关系在运行之前就确定了
动态代理是指在程序运行时通过反射机制动态的生成代理类的字节码文件，代理类和被代理类的关系在运行时才确定

Java中的NIO
Java中的NIO是指New IO，它是JDK1.4之后出现的新特性，它提供了一套新的IO操作方式，可以实现非阻塞的IO操作
Java中的NIO主要有三个核心概念：Channel、Buffer和Selector
Channel表示一个连接，可以通过Channel进行数据的读写
Buffer表示一个缓冲区，可以通过Buffer进行数据的读写
Selector表示一个选择器，可以通过Selector来监控多个Channel的状态，从而实现单线程管理多个Channel

Java中的AIO
Java中的AIO是指Asynchronous IO，它是JDK1.7之后出现的新特性，它提供了一套新的IO操作方式，可以实现异步的IO操作
Java中的AIO主要有两个核心概念：AsynchronousServerSocketChannel和AsynchronousSocketChannel
AsynchronousServerSocketChannel表示异步的ServerSocketChannel，可以通过它来实现异步的ServerSocket
AsynchronousSocketChannel表示异步的SocketChannel，可以通过它来实现异步的Socket

Java中的线程池
Java中的线程池是指一种线程的管理方式，它可以实现线程的复用，避免了线程的频繁创建和销毁，从而提高了程序的性能
Java中的线程池主要有两种：ThreadPoolExecutor和ScheduledThreadPoolExecutor
ThreadPoolExecutor是一个线程池，它可以实现线程的复用
ScheduledThreadPoolExecutor是一个定时任务的线程池，它可以实现定时任务的执行


Java中的锁
Java中的锁主要有两种：悲观锁和乐观锁
悲观锁是指在执行操作之前先获取锁，从而保证操作的安全性，Java中的synchronized关键字和ReentrantLock类都是悲观锁
乐观锁是指在执行操作之前不获取锁，而是在执行操作之后再去判断操作是否安全，Java中的CAS操作就是乐观锁

Java中的CAS
Java中的CAS是指Compare And Swap，它是一种乐观锁，它可以实现多线程的并发操作
Java中的CAS主要有三个方法：getAndAddInt、getAndAddLong和getAndAddLong
getAndAddInt方法是用来对int类型的数据进行加法操作的，它的底层是通过Unsafe类的compareAndSwapInt方法实现的
getAndAddLong方法是用来对long类型的数据进行加法操作的，它的底层是通过Unsafe类的compareAndSwapLong方法实现的
getAndAddLong方法是用来对Object类型的数据进行加法操作的，它的底层是通过Unsafe类的compareAndSwapObject方法实现的

Java中的CAS的缺点
Java中的CAS虽然可以实现多线程的并发操作，但是它也有缺点，那就是ABA问题
ABA问题是指在CAS操作过程中，如果一个值原来是A，后来被改成了B，然后又被改回了A，那么CAS操作就会误认为它从来没有被改变过
Java中的AtomicStampedReference类可以解决ABA问题，它可以通过版本号来判断值是否被改变过

Java中的线程通信
Java中的线程通信主要有两种方式：wait和notify
wait方法是用来使线程等待的，它可以使线程从运行状态进入到等待状态
notify方法是用来唤醒线程的，它可以使处于等待状态的线程从等待状态进入到运行状态
wait方法和notify方法必须要在同步代码块中使用，因为它们必须要先获取锁才能调用

Java中的线程通信的缺点
Java中的线程通信虽然可以实现线程的同步，但是它也有缺点，那就是只能唤醒一个线程
Java中的Condition类可以解决线程通信的缺点，它可以实现唤醒多个线程

Java中的线程池
Java中的线程池是指一种线程的管理方式，它可以实现线程的复用，避免了线程的频繁创建和销毁，从而提高了程序的性能
Java中的线程池主要有两种：ThreadPoolExecutor和ScheduledThreadPoolExecutor
ThreadPoolExecutor是一个线程池，它可以实现线程的复用
ScheduledThreadPoolExecutor是一个定时任务的线程池，它可以实现定时任务的执行

Java中的线程池的缺点
Java中的线程池虽然可以实现线程的复用，但是它也有缺点，那就是线程池的大小是固定的
Java中的ForkJoinPool类可以解决线程池的缺点，它可以实现线程池的大小动态调整

深拷贝和浅拷贝
深拷贝是指在拷贝对象时，会将对象的所有属性都拷贝一份，从而实现两个对象的独立
浅拷贝是指在拷贝对象时，只会将对象的基本类型的属性拷贝一份，而不会将对象的引用类型的属性拷贝一份，从而实现两个对象的共享


HashMap的扩容机制
HashMap的扩容机制是指当HashMap中的元素个数超过了负载因子和容量的乘积时，就会对HashMap进行扩容
HashMap的负载因子默认是0.75，HashMap的容量默认是16
HashMap的扩容机制是通过resize方法实现的，它会将HashMap中的元素重新分配到新的数组中
HashMap的扩容机制是通过transfer方法实现的，它会将HashMap中的元素重新分配到新的数组中

HashMap的扩容机制的缺点
HashMap的扩容机制虽然可以实现HashMap的扩容，但是它也有缺点，那就是会造成死循环
HashMap的扩容机制是通过transfer方法实现的，它会将HashMap中的元素重新分配到新的数组中


HashMap的线程安全问题
HashMap是线程不安全的，因为它不是线程安全的，所以在多线程的环境下，可能会出现死循环的情况

HashMap的线程安全问题的解决方案
HashMap的线程安全问题可以通过Collections.synchronizedMap方法解决，它可以将HashMap转换成线程安全的HashMap

CopyOnWriteArrayList的底层原理是什么
CopyOnWriteArrayList的底层原理是指在对CopyOnWriteArrayList进行写操作时，会将CopyOnWriteArrayList中的元素复制一份，然后再进行写操作

字节码的好处
字节码的好处是指在程序运行之前，可以对字节码进行修改，从而实现程序的热部署


双亲委派模型
双亲委派模型是指在加载一个类时，会先将这个类的加载任务委派给它的父类加载器，如果父类加载器还存在父类加载器，那么会继续向上委派，直到委派给BootstrapClassLoader为止

双亲委派模型的好处
双亲委派模型的好处是指可以避免类的重复加载，从而保证类的唯一性

双亲委派模型的缺点
双亲委派模型的缺点是指在加载一个类时，会先将这个类的加载任务委派给它的父类加载器，如果父类加载器还存在父类加载器，那么会继续向上委派，直到委派给BootstrapClassLoader为止，这样会导致类的加载速度变慢

GC如何判断对象是否存活
GC如何判断对象是否存活是指在GC进行垃圾回收时，会判断对象是否存活，如果对象存活，那么就不会对这个对象进行垃圾回收，如果对象不存活，那么就会对这个对象进行垃圾回收

在Java中，垃圾收集器（GC）的主要任务就是自动管理内存，它通过跟踪每个对象的生命周期，判断哪些对象仍在使用（活动对象），哪些对象已经不再使用（非活动对象或可回收对象）。以下是GC判断对象是否存活的基本原则：

1. **可达性分析（Reachability Analysis）**：GC主要通过可达性分析来判断一个对象是否仍然存活。在这个过程中，GC会从一组被称为"GC Roots"的对象开始，通过这些对象的引用，找到它们引用的对象，再通过这些对象找到其他被引用的对象，这样逐步扩展，最终找出所有可以从GC Roots直接或间接访问到的对象。这些对象被认为是活动的，也就是还在使用的对象，而那些从GC Roots无法访问到的对象则被认为是非活动的，也就是可以被回收的对象。

2. **引用类型**：Java中还有一些特殊的引用类型，如SoftReference、WeakReference、PhantomReference和ReferenceQueue，它们和垃圾收集的行为有关。例如，只有WeakReference指向的对象，在下一次垃圾收集时就会被回收；而SoftReference指向的对象，只有在内存不足时才会被回收；PhantomReference则常常用来跟踪对象被回收的状态。

注意，GC仅仅是判断对象是否仍然存活的机制，而决定何时进行垃圾收集的算法（例如标记-清除（Mark-Sweep）、复制（Copying）、标记-压缩（Mark-Compact）等）则由具体的垃圾收集器决定，如Serial Collector、Parallel Collector、Concurrent Mark Sweep (CMS) Collector、G1 Collector等。

7
